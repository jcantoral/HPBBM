# R script 1
#1. Scripts
#1.1

rm(list=ls())
x <- seq(from=123, to=297, by=3.5)
summary(x)

# 1.2
#1.2.1 Either copying the code or 
##by opening <kbd>File > Open File (Ctrl+O)</kbd>,
##then selecting and running as <kbd>Ctrl + Enter</kbd>
#1.2.2 source("path/to/file.R", echo=TRUE) 
#1.2.3 $R --vanilla < path/to/file.R 
# 2. Some read.table operations
#2.1
d1 <- read.table ("d1.txt", header = TRUE) 
#2.2
d2 <- read.table ("d2.txt", header = TRUE, na.strings= " ", sep= "\t") 
#2.3
d3 <- read.table ("d3.txt", header = FALSE, na.strings= " ", sep= "\t")  
#2.4
d4 <- read.table ("d4.txt", header = TRUE, comment.char="@")  

# 3. Packages

#3.1 Running a sessionInfo() command specifies
##versions of all packages that are installed.
##Up-to-date version is 2.4.0.

#3.2 Same as 3.1. 

#3.3 The user first needs to "require" the package, running require(OncoSimulR),
##then OncoSimulR::oncoSimulIndiv()

# 4. The Help
#4.1 A message "character(0)" appears. 
#4.2 A message suggesting the function "car::scatter3d" appears. 
#4.3 The message "character(0)" is now replaced for "scatter3d". 
#4.4 According to the help, "apropos()" returns a vector including the names
##of all objects matching the query.
##We guess "apropos" needs the object to actually exist,
##and "scatter3d" only exists after requiring the "car" package.
##On the contrary, "help.search" returns the help information for the result 
##of a search function. "search" looks through all packages,
#not only those that have been loaded. 
#4.5 See answer 4.4. 
#4.6 Definitely help.search is better. apropos would miss any package
##that is installed but not loaded in the session. 
#4.7

help.search("",package=NULL)

# 5. Saving objects
#5.1
x <- 97
y <- 95
save(x, file="oneObject.RData")
unlink("oneObject.RData")
unlink(".RData")

#5.2
save.image() #saves the current workspace.

#6.Vectors, data frames, etc.
hr <- c(87, 78, 86, 62, 69, 69, 68, 67, 75, 76)

#6.1
age <- c(rep(11, 3), rep(63, 2), rep(40, 4), 47)
#6.2
hr[which(age < 45)]

#6.3
hr2 <- (c(hr[which(age == 63)], hr[which(age == 47)]))
names.patients <- c("Juan", "Ana", "Carmen")
names(hr2) <- names.patients

#6.4
hr2["Juan"]
hr2["Ana"]

#6.5
matrix.patients <- matrix(c(hr2, rep(63, 2), 47), ncol=2)
rownames(matrix.patients) <- names.patients

#6.6
DF.patients <- data.frame(row.names = names.patients)
DF.patients$"Hear rate" <- hr2
DF.patients$Age <- c(rep(63,2), 47)

#6.7
Juan <- data.frame(Name = "Juan", "Hr" = 62, Age = 63)
Ana <- data.frame(Name = "Ana", "Hr" = 69, Age = 63)
Carmen <- data.frame(Name = "Carmen", "Hr" = 76, Age = 47)
DF2.patients <- rbind(Juan, Ana, Carmen)

DF.patients1 <- data.frame(row.names = c(1,2,3))
DF.patients1$"Hear rate" <- hr2
DF.patients1$Age <- c(rep(63,2), 47)
DF.patients1$Name<- names.patients
#Se me ha ocurrido esta otra forma que seria prácticamente igual a la del ejercicio anterior, pero vamos que coged la que queráis.

#We could not do this with a matrix, because in a matrix all elements must
##have the same class

#6.8
##Index
matrix.patients[1,1]

##Row names
matrix.patients["Juan", 1]

#6.9
matrix.patients["Juan", ]

#6.10
DF.patients["Ana", 1]

#6.11
DF2.patients[2, 2]

#6.12
DF2.patients[2, ]

#6.13
DF2.patients[which(DF2.patients$Age > 60), ]

#6.14
DF.patients[which(DF.patients$Age > 60), ]

#6.15
matrix.all <- matrix(c(hr, age), ncol=2)
matrix.15 <- matrix.all[which(matrix.all[ , 2] > 15), ]

#6.16
##They could correspond to the individuals above, but there is one value that
##does not match, the last on. Values for 10 individuals are expected,
##but the sex vector contains 11 values.

#6.17
sex <- c("M", "F")[c(1, 2, 1, 1, 2, 2, 1, 1, 2, 2)]
matrix.15 <- cbind(matrix.15, sex[which(matrix.all[ , 2] > 15)])

#6.18
DF.patients$Sex <- c(matrix.15[which(matrix.15[,2] == 63), 3], 
                     matrix.15[which(matrix.15[,2] == 47), 3])


#7.Sort and order
#7.1. Using the matrix created in exercise 6, 6.15,
##create a new matrix that contains the exact same data3
##but such that the values are ordered in such a way
##that you first order by age and then by heart rate.
##So you want the youngest individuals on top, and within age,
##you wantthe slowest heart rates on top. So we would get this:
## hr age
## [1,] 67 40
## [2,] 68 40
## [3,] 69 40
## [4,] 75 40
## [5,] 76 47
## [6,] 62 63
## [7,] 69 63

hr.o <- tab1[order(tab1[,2],tab1[,1])]
age.o <- sort(tab1[,2])
tab.o <- cbind(age.o,hr.o)
